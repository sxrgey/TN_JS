//Что будет в результате вызова?
let arr = new Array(4).fill('2').map(parseInt);
/*
В результате данного вызова будет получен массив чисел [2, NaN, NaN, 2], 
потому что в функции parseInt не было указано явно, что передается в качестве
аргументов.
Также в методе .map() по умолчанию существует 3 параметра: val, index
и array, а явного указания на использования меньшего количества передаваемых 
аргументов не было.

Как итог, мы имеем неверный результат работы:
на каждой итерации функции parseInt передаются аргументы val и index: parseInt(val, index)
parseInt принмает 2 аргумента – строку и систему счисления, причем если в качестве системы счисления
указано ложное значение, система счисления принимается за десятичную.
на первой итерации будет передано ('2', 0) –> корректно переводим в 2 по 10й СС
на второй итерации будет передано ('2', 1) –> в единичной СС нет цифры 2, отсюда получаем NaN
аналогично на третьей итерации ('2', 2), т.к. в 2ой СС есть только 0 и 1
на четвертой итерации ('2', 3) получаем 2 в 3ой СС
*/
//Выведем результат работы в консоль
console.log(arr); //[ 2, NaN, NaN, 2 ]

//Как бы стоило сделать?
//1й вариант
let arr1 = new Array(4).fill('2').map(n => parseInt(n, 10));
console.log(arr1); //[ 2, 2, 2, 2 ]

//2й вариант
let arr2 = new Array(4).fill('2').map(n => parseInt(n));
console.log(arr2); //[ 2, 2, 2, 2 ]
/*
Во 2ом варианте нет явного указания системы счисления для parseInt, поэтому
вторым аргументом будет передан undefined, что ялвяется ложным значением, из
чего следует, что система счисления будет взята за десятичную.
Однако в документации рекомендуют явно указывать систему счисления, чтобы
избежать непредсказуемого поведения.
*/
